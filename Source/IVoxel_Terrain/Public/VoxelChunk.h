#pragma once

#include "CoreMinimal.h"
#include "BlockState.h"
#include "IVoxel_Terrain.h"
#include "GameFramework/Actor.h"
#include "HAL/ThreadSafeBool.h"
#include "VoxelChunk.generated.h"

class AVoxelWorld;
class FBlockState;
class AVoxelChunkRender;
class UVoxelWorldGenerator;
template<typename T>
class TAbstractBlockStorage;
struct FBlockPos;

UENUM(BlueprintType)
enum class EChunkState : uint8
{
	//Invalid chunk
	CS_Invalid,
	//Maybe pre generated chunk, has no render
	CS_NoRender,
	//Temporary chunk generated by world generator
	CS_WorldGenGenerated,
	//This chunk should be rendered
	CS_Rendered,
	//This chunk is being deleted
	CS_QueuedDeletion
};

enum class EWorldGenState : uint8
{
	NOT_GENERATED,
	GENERATING,
	GENERATED,
	DIRTYSET
};

UCLASS(Blueprintable)
class IVOXEL_TERRAIN_API UVoxelChunk : public UObject
{
    GENERATED_BODY()

protected:
    FIntVector ChunkPosition;
    AVoxelWorld* World;

    bool RenderDirty = false;

	UPROPERTY()
	UVoxelWorldGenerator* WorldGenerator;

	TSharedPtr<TAbstractBlockStorage<FBlockState>> BlockStateStorage;
	TSharedPtr<TAbstractBlockStorage<FFaceVisiblityCache>> FaceVisiblityCache;

	EChunkState ChunkState = EChunkState::CS_Invalid;
	FCriticalSection ChunkStateLock;

public:
	//Can be null
	UPROPERTY()
	AVoxelChunkRender* RenderActor = nullptr;

	FThreadSafeCounter WorldGeneratorsReferences;

	EWorldGenState WorldGenState = EWorldGenState::NOT_GENERATED;

public:
    UVoxelChunk();

    virtual void ChunkTick();

    void Initialize(AVoxelWorld* VoxelWorld, FIntVector ChunkIndex);

    void InitRender();
    void DeInitRender();
	bool HasRender();

	void GenerateWorld();

	//Only lock when your operation is not in game thread
	void BlockStateStorageLock();
	void BlockStateStorageUnlock();

	bool IsValidChunk();

    FBlockState* GetBlockState(FBlockPos Pos);
	UFUNCTION(BlueprintCallable)
	void SetBlock(FBlockPos Pos, UBlock* Block);

	FFaceVisiblityCache& GetFaceVisiblityCache(FBlockPos Pos);

	void UpdateBlock(FBlockPos Pos);

	void GetAdjacentChunks(TArray<UVoxelChunk*>& Ret);

	bool ShouldBeRendered();
	bool ShouldBeTicked();
	bool ShouldBeDeleted();

//Chunk state related functions
public:
	EChunkState GetChunkState();

	void TrySetChunkState(EChunkState NewState);

public:
    AVoxelWorld* GetVoxelWorld();

    FIntVector GetChunkPosition();

    AVoxelChunkRender* GetRender();

	void SetRenderDirty();

	inline FIntVector GetGlobalPosition_Min()
	{
		return ChunkPosition * VOX_CHUNKSIZE;
	}
	inline FIntVector GetGlobalPosition_Max()
	{
		return (ChunkPosition + FIntVector(1)) * VOX_CHUNKSIZE - FIntVector(1);
	}

	inline bool IsInChunk(FIntVector GlobalPos)
	{
		FIntVector Min = GetGlobalPosition_Min();
		FIntVector Max = GetGlobalPosition_Max();
		return GlobalPos.X >= Min.X && GlobalPos.X < Max.X
			&& GlobalPos.Y >= Min.Y && GlobalPos.Y < Max.Y
			&& GlobalPos.Z >= Min.Z && GlobalPos.Z < Max.Z;
	}

    FIntVector LocalToGlobalPosition(FIntVector LocalPos);
    FIntVector GlobalToLocalPosition(FIntVector GlobalPos);

	FVector GetWorldPosition();
};
