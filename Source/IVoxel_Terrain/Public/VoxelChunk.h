#pragma once

#include "CoreMinimal.h"
#include "BlockState.h"
#include "IVoxel_Terrain.h"
#include "GameFramework/Actor.h"
#include "HAL/ThreadSafeBool.h"
#include "VoxelChunk.generated.h"

class AVoxelWorld;
class FBlockState;
class AVoxelChunkRender;
class UVoxelWorldGenerator;
class FAbstractBlockStorage;
struct FBlockPos;
class FChunkUniversalThread;

UENUM(BlueprintType)
enum class EChunkState : uint8
{
	//Invalid chunk
	CS_Invalid,
	//Maybe pre generated chunk, has no render
	CS_NoRender,
	//Temporary chunk generated by world generator
	CS_WorldGenGenerated,
	//This chunk should be rendered
	CS_Rendered,
	//This chunk is being deleted
	CS_QueuedDeletion
};

enum class EWorldGenState : uint8
{
	NOT_GENERATED,
	GENERTING_PRIME,
	GENERTED_PRIME,
	GENERATING_POST,
	GENERATED_POST
};

class IVOXEL_TERRAIN_API UPrimeChunk
{
public:
	FAbstractBlockStorage* BlockStorage;

	UPrimeChunk();
	~UPrimeChunk();

	void SetBlockDef(int X, int Y, int Z, UBlock* Block);

	UBlock* GetBlockDef(int Index);
};

template<typename T>
class IVOXEL_TERRAIN_API FNonDeleter
{
public:
	inline void operator() (T* Type) {};
};

class IVOXEL_TERRAIN_API UVoxelChunk
{
protected:
    FIntVector ChunkPosition;
    AVoxelWorld* World;

	FThreadSafeBool RenderDirty = false;

	UVoxelWorldGenerator* WorldGenerator;

	FAbstractBlockStorage* BlockStorage;
	FFaceVisiblityCache FaceVisiblityCache[VOX_CHUNKSIZE_ARRAY];

	EChunkState ChunkState = EChunkState::CS_Invalid;

	FCriticalSection ChunkStateLock;

	FChunkUniversalThread* UniversalThread = nullptr;

	TSharedPtr<UVoxelChunk> ThisSharedPtr;
	
	FAdjacentChunkCache AdjacentCache;

public:
	//Can be null
	AVoxelChunkRender* RenderActor = nullptr;

	FThreadSafeCounter WorldGeneratorsReferences;

	EWorldGenState WorldGenState = EWorldGenState::NOT_GENERATED;

	UPrimeChunk PrimeChunk;

public:
    UVoxelChunk();
	virtual ~UVoxelChunk();

    virtual void ChunkTick();

    void Initialize(AVoxelWorld* VoxelWorld, FIntVector ChunkIndex);

    void InitRender();
    void DeInitRender();
	bool HasRender();

	void GenerateWorld();
	void PostGenerateWorld();

	void ProcessPrimeChunk();

	bool IsValidChunk();

	void SetBlock(FBlockPos Pos, UBlock* Block, bool DoUpdate = true);
	UBlock* GetBlock(FBlockPos Pos);

	inline FFaceVisiblityCache& GetFaceVisiblityCache(FBlockPos& Pos)
	{
		//check(Pos.GetChunk() == this);
		return FaceVisiblityCache[Pos.ArrayIndex()];
	}

	inline void UpdateBlock(FBlockPos& Pos);
	inline void UpdateFaceVisiblity(FBlockPos& Pos);

	void GetAdjacentChunks(TArray<UVoxelChunk*>& Ret);
	void GetAdjacentChunks_Corner(TArray<UVoxelChunk*>& Ret);

	UVoxelChunk* GetAdjacentChunkByFace(EBlockFace Face);

	bool ShouldBeRendered();
	bool ShouldBeTicked();
	bool ShouldBeDeleted();
	bool ShouldPostGenerate();

	void QueuePreWorldGeneration();
	void QueuePostWorldGeneration();
	void QueuePolygonize();

	bool IsDoingWorkNow();

	TWeakPtr<UVoxelChunk> GetWeakPtr();

//Chunk state related functions
public:
	EChunkState GetChunkState();

	void TrySetChunkState(EChunkState NewState);

public:
    AVoxelWorld* GetVoxelWorld();

    FIntVector GetChunkPosition();

    AVoxelChunkRender* GetRender();

	void SetRenderDirty();

	inline FIntVector GetGlobalPosition_Min()
	{
		return ChunkPosition * VOX_CHUNKSIZE;
	}
	inline FIntVector GetGlobalPosition_Max()
	{
		return (ChunkPosition + FIntVector(1)) * VOX_CHUNKSIZE - FIntVector(1);
	}

	inline bool IsInChunk(FIntVector& GlobalPos)
	{
		FIntVector Min = GetGlobalPosition_Min();
		FIntVector Max = GetGlobalPosition_Max();
		return GlobalPos.X >= Min.X && GlobalPos.X <= Max.X
			&& GlobalPos.Y >= Min.Y && GlobalPos.Y <= Max.Y
			&& GlobalPos.Z >= Min.Z && GlobalPos.Z <= Max.Z;
	}

    FIntVector LocalToGlobalPosition(FIntVector LocalPos);
    FIntVector GlobalToLocalPosition(FIntVector GlobalPos);

	FVector GetWorldPosition();
};
