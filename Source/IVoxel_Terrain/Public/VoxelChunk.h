#pragma once

#include "CoreMinimal.h"
#include "BlockState.h"
#include "IVoxel_Terrain.h"
#include "GameFramework/Actor.h"
#include "HAL/ThreadSafeBool.h"
#include "VoxelChunk.generated.h"

class AVoxelWorld;
class FBlockState;
class AVoxelChunkRender;
class UVoxelWorldGenerator;
template<typename T>
class TAbstractBlockStorage;
struct FBlockPos;

typedef TFunction<void(FBlockState*)> StateModifyFunction;

UENUM(BlueprintType)
enum class EChunkState : uint8
{
	//Invalid chunk
	CS_Invalid,
	//Maybe pre generated chunk, has no render
	CS_NoRender,
	//Temporary chunk generated by world generator
	CS_WorldGenGenerated,
	//This chunk should be rendered
	CS_Rendered,
	//This chunk is being deleted
	CS_QueuedDeletion
};

enum class EWorldGenState : uint8
{
	NOT_GENERATED,
	GENERTING_PRIME,
	GENERTED_PRIME,
	VISIBLITY_UPDATING,
	VISIBLITY_UPDATED,
	GENERATING_POST,
	GENERATED_POST
};

class IVOXEL_TERRAIN_API UPrimeChunk
{
public:
	UBlock* Blocks[VOX_CHUNKSIZE_ARRAY];

	UPrimeChunk();

	void SetBlockDef(int X, int Y, int Z, UBlock* Block);
};

//184KB
//Or, Nearly 200KB including(assuming) UObject
UCLASS(Blueprintable)
class IVOXEL_TERRAIN_API UVoxelChunk : public UObject
{
    GENERATED_BODY()

protected:
    FIntVector ChunkPosition;
    AVoxelWorld* World;

    bool RenderDirty = false;

	UPROPERTY()
	UVoxelWorldGenerator* WorldGenerator;

	TAbstractBlockStorage<FBlockState>* BlockStateStorage = nullptr;
	TAbstractBlockStorage<FFaceVisiblityCache>* FaceVisiblityCache = nullptr;

	EChunkState ChunkState = EChunkState::CS_Invalid;
	FCriticalSection ChunkStateLock;

public:
	//Can be null
	UPROPERTY()
	AVoxelChunkRender* RenderActor = nullptr;

	FThreadSafeCounter WorldGeneratorsReferences;

	EWorldGenState WorldGenState = EWorldGenState::NOT_GENERATED;

	UPrimeChunk PrimeChunk;

public:
    UVoxelChunk();
	~UVoxelChunk();

    virtual void ChunkTick();

    void Initialize(AVoxelWorld* VoxelWorld, FIntVector ChunkIndex);

    void InitRender();
    void DeInitRender();
	bool HasRender();

	void GenerateWorld();
	void PostGenerateWorld();
	void UpdateFaceVisiblityAll();

	void ProcessPrimeChunk();

	//Only lock when your operation is not in game thread
	void BlockStateStorageLock();
	void BlockStateStorageUnlock();

	bool IsValidChunk();

	FBlockState* GetBlockState(FBlockPos& Pos);
	inline void ModifyBlockState(FBlockPos& Pos, StateModifyFunction Func, bool SetDirty = true);

	UFUNCTION(BlueprintCallable)
	void SetBlock(FBlockPos Pos, UBlock* Block);

	FFaceVisiblityCache& GetFaceVisiblityCache(FBlockPos& Pos);

	inline void UpdateBlock(FBlockPos& Pos);
	inline void UpdateFaceVisiblity(FBlockPos& Pos);

	void GetAdjacentChunks(TArray<UVoxelChunk*>& Ret);
	void GetAdjacentChunks_Corner(TArray<UVoxelChunk*>& Ret);

	bool ShouldBeRendered();
	bool ShouldBeTicked();
	bool ShouldBeDeleted();
	bool ShouldPostGenerate();
	bool ShouldUpdateFaceVisiblity();


//Chunk state related functions
public:
	EChunkState GetChunkState();

	void TrySetChunkState(EChunkState NewState);

public:
    AVoxelWorld* GetVoxelWorld();

    FIntVector GetChunkPosition();

    AVoxelChunkRender* GetRender();

	inline void SetRenderDirty()
	{
		RenderDirty = true;
	};

	inline FIntVector GetGlobalPosition_Min()
	{
		return ChunkPosition * VOX_CHUNKSIZE;
	}
	inline FIntVector GetGlobalPosition_Max()
	{
		return (ChunkPosition + FIntVector(1)) * VOX_CHUNKSIZE - FIntVector(1);
	}

	inline bool IsInChunk(FIntVector GlobalPos)
	{
		FIntVector Min = GetGlobalPosition_Min();
		FIntVector Max = GetGlobalPosition_Max();
		return GlobalPos.X >= Min.X && GlobalPos.X < Max.X
			&& GlobalPos.Y >= Min.Y && GlobalPos.Y < Max.Y
			&& GlobalPos.Z >= Min.Z && GlobalPos.Z < Max.Z;
	}

    FIntVector LocalToGlobalPosition(FIntVector LocalPos);
    FIntVector GlobalToLocalPosition(FIntVector GlobalPos);

	FVector GetWorldPosition();
};
